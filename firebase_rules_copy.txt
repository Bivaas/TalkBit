Firestore rules (copy into your `firestore.rules` file)

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper to detect admin via custom claim or admin email
    function isAdmin() {
      return request.auth != null && (
        (request.auth.token.admin == true) || (request.auth.token.email == 'admin@chatapp.com')
      );
    }

    // Protect user profiles: only owner can create/update their doc; admins can read/delete
    match /users/{userId} {
      allow read: if request.auth != null && (request.auth.uid == userId || isAdmin());

      allow create: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.keys().hasOnly(['uid','name','email','isOnline','createdAt'])
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.email == request.auth.token.email
        // limit creation timestamp skew (client should set server timestamp ideally)
        && request.time.toMillis() - request.resource.data.createdAt.toMillis() < 60000;

      allow update: if request.auth != null && request.auth.uid == userId;
      allow delete: if isAdmin();
    }

    // Admin documents only writeable/readable by admins
    match /admin/{doc} {
      allow read, write: if isAdmin();
    }

    // Basic protections for any messages stored in Firestore (if used)
    match /messages/{messageId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null
        && request.resource.data.senderId == request.auth.uid
        && request.resource.data.text is string
        && request.resource.data.text.size() > 0
        && request.resource.data.text.size() <= 2000
        && request.time.toMillis() - request.resource.data.timestamp.toMillis() <= 86400000;
      allow update, delete: if isAdmin();
    }
  }
}


Realtime Database rules (copy into your `database.rules.json` or deploy as JSON)

{
  "rules": {
    ".read": "auth != null",
    ".write": "auth != null",

    "messages": {
      "global": {
        "$msgId": {
          ".write": "auth != null && newData.exists() && newData.child('senderId').val() === auth.uid && newData.child('text').isString() && newData.child('text').val().length > 0 && newData.child('text').val().length <= 2000 && newData.child('timestamp').val() <= now + 5000 && newData.child('timestamp').val() >= now - 86400000 && newData.child('hash').isString() && root.child('messageHashes').child(newData.child('hash').val()).val() == null",
          ".validate": "newData.hasChildren(['senderId','text','timestamp','chatId','chatType','hash'])"
        }
      },
      "direct": {
        "$chatId": {
          "$msgId": {
            ".write": "auth != null && newData.exists() && newData.child('senderId').val() === auth.uid && newData.child('text').isString() && newData.child('text').val().length > 0 && newData.child('text').val().length <= 2000 && newData.child('timestamp').val() <= now + 5000 && newData.child('timestamp').val() >= now - 86400000 && newData.child('hash').isString() && root.child('messageHashes').child(newData.child('hash').val()).val() == null",
            ".validate": "newData.hasChildren(['senderId','text','timestamp','chatId','chatType','hash','receiverId'])"
          }
        }
      }
    },

    "messageHashes": {
      "$hash": {
        ".write": "auth != null && !data.exists() && newData.val() === auth.uid",
        ".read": "auth != null"
      }
    },

    "presence": {
      "$uid": {
        ".read": "auth != null",
        ".write": "auth != null && (auth.uid === $uid || root.child('admins').child(auth.uid).val() === true)",
        ".validate": "newData.hasChildren(['name','isGuest','online','lastSeen'])"
      }
    },

    "admins": {
      ".read": "auth != null && root.child('admins').child(auth.uid).val() === true",
      ".write": "auth != null && root.child('admins').child(auth.uid).val() === true"
    },

    "userProfiles": {
      "$uid": {
        ".read": "auth != null && (auth.uid === $uid || root.child('admins').child(auth.uid).val() === true)",
        ".write": "auth != null && (
          (!data.exists() && auth.uid === $uid && newData.child('email').val() === auth.token.email && newData.child('createdAt').val() <= now + 5000 && newData.child('createdAt').val() >= now - 60000)
          || (data.exists() && auth.uid === $uid)
          || (root.child('admins').child(auth.uid).val() === true)
        )",
        ".validate": "newData.hasChildren(['name','email','createdAt'])"
      }
    },

    "metadata": {
      "lastWrite": {
        "$uid": {
          ".read": "auth != null && (auth.uid === $uid || root.child('admins').child(auth.uid).val() === true)",
          ".write": "auth != null && auth.uid === $uid"
        }
      },
      "userCreation": {
        "$creator": {
          ".read": "auth != null && (auth.uid === $creator || root.child('admins').child(auth.uid).val() === true)",
          ".write": "auth != null && auth.uid === $creator"
        }
      }
    }
  }
}


Quick deploy commands

firebase deploy --only database
firebase deploy --only firestore

Or deploy both at once:

firebase deploy --only database,firestore

Notes:
- The RTDB rules rely on a `messageHashes/{hash}` node; write the message and create the hash node atomically with an `update()` so duplicates are rejected.
- Use server-side checks (Cloud Functions) for strict per-user/IP rate-limiting and anti-abuse; rules alone can't strongly enforce rate limits.
- Prefer custom claims (`admin` claim) for admin checks rather than relying on a hard-coded email.
